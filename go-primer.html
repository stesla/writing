<p>Google recently announced their new programming language, Go.</p>

<!-- More introduction here -->

<h2>What is Go?</h2>
** Experimental
** Simple, fast, safe, concurrent
** Designed to solve the kinds of problems Google faces
** Essentially C 2.0

<h2>Reading Go</h2>

<p>Go's syntax continues in the same vein as C's. Programs are organized as functions whose bodies are a sequence of statements. Blocks of code are surrounded by curly-braces. The language has a limited set of reserved keywords. Expressions use the same infix operators. There are very few syntactical surprises.</p>

<p>The Go authors have adhered to a single guiding principle when designing the language: simplicity and clarity above all else. Several of the new syntactical constructs provide concise means to express common idioms that are more verbose in C. Others address language choices that, after several decades of use, have been shown to be unwise.</p>

<h3>Variable Declarations</h3>

<p>Variables are declared as follows:</p>

<pre>var sum int // Just a declaration
var total int = 42 // A declaration with initialization</pre>

<p>Most notably, the type in these declarations comes <em>after</em> the variable name. This may seem strange at first, but has some benefits on clarity. For example, take the following snippet of C:</p>

<pre>int* a, b;</pre>

<p>It is not apparent, but that actually means that <code>a</code> is a pointer and <code>b</code> is not. In order to declare them both pointers, the asterisk must be repeated. However in Go, they can both be declared pointers as follows:</p>

<pre>var a, b *int</pre>

<p>If a variable is being initialized, the compiler can typically infer its type, so it is not necessary for the programmer to type it out:</p>

<pre>var label = "name"</pre>

<p>However, at that point, the <code>var</code> keyword is almost superfluous. So, the Go authors introduced a new assignment operator which both declares and initializes a new variable:</p>

<pre>name := "Samuel"</pre>

<h3>Conditionals</h3>

<p>Conditionals in Go have the familiar if-else construction as those in C, but the condition need not be wrapped in parentheses. This creates less visual clutter when reading code.</p>

<p>Parentheses are not the only clutter that have been removed. A simple statement can be included before the condition so that the following code:</p>

<pre>result := someFunc();
if result > 0 {
	/* Do something */
} else {
	/* Handle error */
}</pre>

<p>Can be reduced to this:</p>

<pre>if result := someFunc(); result > 0 { 
	/* Do something */
} else {
	/* Handle error */
}</pre>

<p>However, in the latter example, <code>result</code> is only in scope inside the conditional block. Whereas before it had to be in the containing scope.</p>

<h3>Switches</h3>

<p>Switches once again are similar, but improved. Like conditionals, they allow a simple statement to proceed the expression that is being switched upon. However, they deviate even further from their C counterparts.

<p>First, to make switches more concise, two changes were made. Cases can be comma-separated lists of values, and fallthrough is no longer the default behavior.</p>

<p>So, the following C code:</p>

<pre>int result;
switch (byte) {
 case 'a':
 case 'b':
   {
     result = 1
     break
   }

 default:
   result = 0
}</pre>

<p>Becomes this in Go:</p>

<pre>var result int
switch byte {
case 'a', 'b':
  result = 1
default:
  result = 2
}</pre>

<p>Second, Go switches can match on much more than integers and characters. Any valid expression can be the value of a case statement, so long as it is the same type as the switch expression.</p>

<p>So, the following C code:</p>

<pre>int result = calculate();
if (result &lt; 0) {
  /* negative */
} else if (result &gt; 0) {
  /* positive */
} else {
  /* zero */
}</pre>

<p>Becomes this in Go:</p>

<pre>switch result := calculate(); true {
case result &lt; 0:
  /* negative */
case result &gt; 0:
  /* positive */
default:
  /* zero */
}</pre>

<p>That idiom is so common, that if the switch value is omitted, it is assumed to be true. So the above could be rewritten as:</p>

<pre>switch result := calculate(); {
case result &lt; 0:
  /* negative */
case result &gt; 0:
  /* positive */
default:
  /* zero */
}</pre>


<h3>Loops</h>

Go has only one keyword to introduce a loop. However, it offers all of the looping behaviours available in C except the do-while.

<h4>Condition</h4>

<pre>for a > b { /* ... */ }</pre>

<h4>Initializer, Condition and Step</h4>

<pre>for i := 0; i < 10; i++ { /* ... */ }</pre>

<h4>Range</h4>

The right-hand expression of a range clause must be an array, slice, string or map, or a pointer to an array; or it may be a channel.

<pre>for i := range "hello" { /* ... */ }</pre>

<h4>Infinite</h4>

<pre>for { /* ever */ }</pre>

<h3>Functions</h3>

<p>The syntax for declaring functions differs from C. As with variable declarations, types are declared after the terms they describe. So the following function in C:</p>

<pre>int add(int a, b) { return a + b }</pre>

<p>Becomes this function in Go:</p>

<pre>func add(a, b int) int { return a + b }</pre>

<h4>Multiple Return Values</h4>

<p>A common idiom in C is to either reserve a return value to indicate error (e.g. <code>read()</code> returning 0), or to reserve the return value to communicate status and pass in a pointer to a memory location in which to store results. This encourages unsafe programming practices and is not viable in a managed language such as Go.</p>

<p>Recognizing that this problem extends beyond the simple need to communicate both function results and errors, the Go authors built in the capability to return multiple values from a function.</p>

<p>As an example, a function to return both parts of an integer division:</p>

<pre>func divide(a, b int) (int, int) {
  quotient := a / b
  remainder := a % b
  return quotient, remainder
}</pre>

<p>Recognizing that with multiple return values, it is good to have the code document which is which, you can give the return values names just like parameters. You can then assign values to those return variables just like any other. So we could rewrite <code>divide</code> like this:

<pre>func divide(a, b int) (quotient, remainder int) {
  quotient = a / b
  remainder = a % b
  return
}</pre>

<p>The presence of multiple-return values has given rise to the comma-ok pattern. Functions which can fail can return a second, boolean, result to indicate success. Alternatively, they can return an error object. So it's not uncommon to see code like this:</p>

<pre>if result, ok := moreMagic(); ok {
  /* Do something with result */
}</pre>

<h4>Anonymous Functions</h4>

<p>Having a garbage collector opens the door for a wide variety of features. Among those are anonymous functions. Go provides a simple syntax for declaring anonymous functions. These functions create a lexical closure on the scope in which they were defined like blocks in many dynamic languages.</p>

<p>Consider the following program:</p>

<pre>func makeAdder(x int) (func(int) int) {
  return func(y int) int { return x + y }
}

func main() {
  add5 := makeAdder(5);
  add36 := makeAdder(36);
  fmt.Println("The answer:", add5(add36(1))); //=> The answer: 42
}</pre>

<h3>Primitive Types</h3>

<p>Like C, Go offers a handful of primitive types. The usual boolean, integer and floating-point types are available. It has a unicode string type and an array type. The language also introduces two new types: slice and map.</p>

<h4>Arrays & Slices</h4>

<p>Arrays in Go are not dynamic like they are in C. Their size is part of their type, and is determined at compile time. To index into an array the familiar C syntax is used (e.g. <code>a[i]</code>). The compiler provides a built-in function, which is evaluated at compile time, to determine the length of an array (e.g. <code>len(a)</code>). If a write to an index beyond the bounds of an array is attempted, a run-time error will be generated.</p>

<p>Go also offers slices, which put a new twist on arrays. A slice represents a contiguous segment of an array. However, it need not represent the entire array, and can grow up to that limit. Once again, the length of a slice can be determined at compile-time. The capacity of a slice (retrievable by <code>cap(s)</code>, where <code>s</code> is a slice) determines how much room the slice has to grow. To construct a slice from an array (or another slice) the syntax <code>a[lo:hi]</code> is used, where <code>lo</code> is a zero-based index and <code>hi</code> is a one-based index. If a slice that goes to the end of the array is desired, <code>hi</code> may be omitted.</p>

<p>The following code illustrates how arrays and slices work:</p>

<pre>a := [...]int{1,2,3,4,5} // The ... means "whatever length the initializer has"
len(a) //=> 5

/* Slice from the middle */
s := a[2:4] //=> [3 4]
len(s), cap(s) //=> 2, 3

/* Grow the slice */
s = s[0:3] //=> [3 4 5]
len(s), cap(s) //=> 3, 3

/* Slice all the way to the end */
t := a[3:] //=> [4 5]

/* They all share the same array */
a[4] = 6
a[4] == s[2] == t[1] == 6 //=> true
</pre>
 
<h4>Maps</h4>

<p>One data type that is present in most every dynamic language that is popular to day, but that is missing from C, is a dictionary. Go offers a primitive dictionary type called a map. The following example shows how to make and use a Go map.</p>

<pre>m := make(map[string] int); // A mapping of strings to ints

/* Store some values */
m["foo"] = 42
m["bar"] = 30

/* Read, and cause runtime-error if key is not present. */
x := m["foo"];

/* Read, with comma-ok check; ok will be false if key was not present. */
x, ok := m["bar"]

/* Check for presence of key, _ means "I don't care about this value." */
_, ok := m["baz"] // ok == false

/* Delete a key */
m["bar"] = nil, false</pre>

<h2>Object Orientation</h2>

<p>The Go language supports a style of object-oriented programming similar to that used in C. Data is grouped together into structs, and then functions are defined which operate on those structs. Similar to Python, the language offers a way to define the functions and then call them so that the syntax is not cumbersome.</p>

<h3>Structs</h3>

<p>Declaring a new struct type is simple:</p>

<pre>type Point struct {
  x, y float64
}</pre>

<p>Values of this type can now be allocated using the built-in function <code>new</code>, which returns a pointer to the value in memory with all slots initialized to the zero value.</p>

<pre>var p *Point = new(Point)
p.x = 3
p.y = 4</pre>

<p>That can get verbose, and one of the goals of the Go language is to be concise whenever possible. So a  syntax is provided that both allocates and initializes the struct at the same time:</p>

<pre>var p1 Point = Point{3,4}  // Value
var p2 *Point = &amp;Point{3,4} // Pointer</pre>

<h3>Methods</h3>

<p>Once a type has been declared, functions can be declared which take that type as an implicit first parameter:</p>

<pre>func (self Point) Length() float {
  return math.Sqrt(self.x*self.x + self.y*self.y);
}</pre>

<p>Those functions can then be called as methods on the struct:</p>

<pre>p := Point{3,4}
d := p.Length() //=> 5</pre>

<p>Methods can actually be declared on both value and pointer types. Go will handle referencing or dereferencing objects as appropriate, so it is possible to declare methods on both type <code>T</code> and type <code>*T</code> and have them be used as appropriate.</p>

<p>Let us extend our <code>Point</code> class with a mutator:</p>

<pre>
/* Note the receiver is *Point */
func (self *Point) Scale(factor float64) {
  self.x = self.x * factor
  self.y = self.y * factor
}<pre>

<p>Then we can call it like this:</p>

<pre>p.Scale(2);
d = p.Length() //=> 10</pre>

<p>It is important to understand that the <code>self</code> that is passed in to <code>MoveToXY</code> is a parameter like any other, and parameters are passed-by-value. That is why it must be declared as a pointer type in order to actually change the value. If it were declared as just <code>Point</code>, then the struct that was modified inside the method would not be the same one at the call site.</p>

<h3>Interfaces</h3>

<p>Dynamic languages such as Ruby emphasize a style of object-oriented programming that places more importance on what behavior an object has rather than what type that object is. One of the most powerful features that Go brings with it is the ability to program with that duck-typed mentality, and check for adherence to those defined behaviors at compile time. The name given to the behaviors is <em>interfaces</em>.</p>

<p>Defining an interface is simple:</p>

<pre>type Writer interface {
  Write(p []byte) (n int, err os.Error)
}</pre>

<p>That defines an interface with a method for writing a buffer of bytes. Any object which implements that method also implements the interface. No declarations are required as in Java, the compiler just figures it out. This gives the expressiveness of duck-typing with the safety of static type-checking.</p>

<p>The way interfaces behave in Go allows develoeprs to discover their programs' types as they write them. If there are several objects that all have the behavior, and a programmer wishes to abstract on that behavior, she can create an interface and then use that.</p>

<p>Consider the following code:</p>

<pre>// Somewhere in some code:
type Widget struct {}
func (Widget) Frob() { /* do something */ }

// Somewhere else in the code:
type Sprocket struct {}
func (Sprocket) Frob() { /* do something else */ }

/* New code, and we want to take both Widgets and Sprockets and Frob them */
type Frobber interface {
  Frob()
}

func frobtastic(f Frobber) { f.Frob() }</pre>

<p>It is important to note that every object implements the empty interface:</p>

<pre>interface {}</pre>

<h3>Inheritance</h3>

<p>The Go language does not have inheritance, at least not the way most languages do. There is no hierarchy of types. Go encourages the use of composition and delegation over inheritance, and offers some syntax sugar to make it more bearable.</p>

<p>Given these definitions:</p>

<pre>type Engine interface {
  Start()
  Stop()
}

type Car struct {
  Engine
}</pre>

<p>I can then write the following:</p>

<pre>func GoToWorkIn(c Car) {
  /* get in car */

  c.Start();

  /* drive to work */

  c.Stop();

  /* get out of car */
}</pre>

<p>When I declared the <code>Car</code> struct, I gave it what is called an <em>anonymous member</em>. That is a member which is identified only by its type. The anonymous member is a member like any other, with a name the same as the type. So I could have also written <code>c.Engine.Start()</code>. The compiler automatically delegates calls made on <code>Car</code> to methods on its <code>Engine</code> if the <code>Car</code> does not have methods of its own to satisfy them.</p>

<p>It is important to note, though, that this is syntax sugar on top of <em>delegation</em> not inheritence. Once the anonymous member's method has been called, flow has been delegated to that method entirely. So you cannot simulate type hierarchy like this:</p>

<pre>type Base struct {}
func (Base) Magic() { fmt.Print("base magic") }
func (self Base) MoreMagic() { 
  self.Magic()
  self.Magic()
}

type Foo struct {
  Base
}
func (Foo) Magic() { fmt.Print("foo magic") }</pre>

<p>When you create a <code>Foo</code> object, it will respond to both methods that <code>Base</code> does. However, when you call <code>MoreMagic</code> you will not get the results you expect:</p>

<pre>f := new(Foo)
f.Magic() //=> foo magic
f.MoreMagic() //=> base magic base magic</pre>

<h2>Concurrency</h2>
Do not communicate by sharing memory; instead, share memory by communicating.

<h3>Goroutines</h3>
*** user-space, lightweight concurrency
*** mapped on to OS concurrency by the runtime

<h3>Channels</h3>
*** Essentially FIFO communication queue.
*** blocking vs non-blocking

<h2>Packages</h2>
** visibility outside of package indicated with Capital letters.
** multiple files, no headers needed.

<h2>What's Missing

<h3>Exceptions</h3>
*** ok/err pattern

<h3>Generics</h3>

<h3>Libraries</h3>
*** Good start of a standard library

<h3>Tools and IDEs</h3>
*** Emacs mode
